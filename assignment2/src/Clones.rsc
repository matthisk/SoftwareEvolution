module Clones

// LIBRARY IMPORTS
import Prelude;

// M3 IMPORTS
import lang::java::m3::AST;

// LOCAL IMPORTS
import Config;
import Util;

@doc{
	Clone Detection Algorithm
	-----------------------
	
	This module contains the core clone detection algorithm. It is based on AST generated by eclipse for java files.
	The clone detector is able to detect type1 and type2 clones. First the algorithm detects all duplicated subtrees, using
	a good hashing function (so no type3 clones are detected). Then sequence clones are detected.
	
	pseudocode:
	-----------
	
	-- DETECT CLONES --
	for all t: subtrees in AST:
		put t in hashmap1 with t as key and set location as value
	for all s: sequences in AST:
		put s in hashmap2 with s as key and set location as value
	
	filter all keys from hashmap1 and 2 where the value has only one location
	
	-- DETECT SUBSUMED CLONES --
	for all k: keys in hashmap1:
		visit all children nodes k:
			if child in hashmap1 and hashmap[k] subsumes hashmap1[child]:
				remove child from hashmap1
	for all seq1 in hashmap2:
		for all seq2 in hashmap2:
			if seq1 is strictsublist seq2 and seq2 subsumes seq2:
				remove seq1 from hashmap
	for all k: keys in hashmap1:
		if direct children k in hashmap2 and hashmap1[k] subsumes hashmap2[children k]:
			remove hashmap2[children k]
	  
	notes:
	------	
	sequences are list of sibling nodes in the AST (which do not appear as their own subtree in the AST).
	the sequence size can be defined in the config.
}

@doc{
	Subsume sequence clones that already exist as a normal clone detected as AST subtree
}
public CloneMap[list[node]] subsumeClones( CloneMap[node] m1, CloneMap[list[node]] m2 ) {
	i = 0;
	
	for( k <- m1 ) {
		if( size(m1) > 10 && i % (size(m1) / 10) == 0 ) print("<percentageOf( i, size(m1) )>% ");
		top-down-break visit( k ) {
			case \block(list[Statement] statements): if( statements in m2 && containsClone( m1[k], m2[statements] ) ) m2[statements] = {};
		}
		i += 1;
	}
	println("");
	
	return filterClones( m2 );
}

@doc{
	Subsume subtree clone classes that already exits 
}
public CloneMap[node] subsumeClones( CloneMap[node] m ) {
	i = 0;
	
	for( k <- m ) {
		if( size(m) > 10 && i % ( size(m) / 10 ) == 0 ) print("<percentageOf(i,size(m))>% ");
		visit( getChildren(k) ) {
			case node n: if(n in m && containsClone( m[k], m[n] )) m[n] = {};
		}
		i += 1;
	}
	println("");
	
	return filterClones( m );
}

public CloneMap[node] subsumeAstClones( CloneMap[node] m ) {
	clones = filterTreshold( filterClones( m ) );
	
	if( SUBSUMBTION_ALGO ) {
		clones = subsumeClones( clones );
	}
	
	return clones;
}

@doc{
	Part of the pseudo algorithm that subsumes sequence clones
	(Very ineffecient algorithmn n^2)
}
public CloneMap[list[node]] subsumeSequenceClones( CloneMap[list[node]] m ) {
	i = 0;
	clones = filterClones( m );
	
	println("sequence clones <size(m)>");
	if( SUBSUMBTION_SEQ_ALGO ) {
		s = size(m) * size(m);
		for( k1 <- m, k2 <- m ) {
			if( s > 10 && i % ( s / 10 ) == 0 ) print("<percentageOf(i,s)>% ");
			if( k1 != k2 && k2 < k1 && containsClone( m[k1], m[k2] ) ) {
				m[k2] = {};
			} elseif( k1 != k2 && size(m[k1]) == size(m[k2]) && set[loc] newLocs := locationsOverlap( m[k1], m[k2] ) && size(newLocs) != 0 ) {
				m[k1] = newLocs;
				m[k2] = {};
			}
			i += 1;
		}
		println("");
	
		clones = filterClones( m );
	}
	
	return filterTreshold(clones);
}

@doc{
	Generate a hashmap of all subtrees in an AST
}
public CloneMap[node] findAstClones( Declaration ast, CloneMap[node] m ) {
	visit( ast ) {
		case node n: if( (Declaration d := n || Statement d := n || Expression d := n) && hasLoc(d) ) m[d] = d in m ? m[d] + d@src : {d@src};
	}

	return m;
} 

@doc{
	Generate a hashmap of all sequences in an AST
}
public CloneMap[list[node]] findSequenceClones( Declaration ast, CloneMap[list[node]] m ) {
	visit( ast ) {
		case n:\block(list[Statement] statements): m = createSequences( n, statements, m );
	}
	
	return m;
}

@doc{
	Loop over all sequences in a block and generate a hashmap
}
public CloneMap[list[node]] createSequences( Statement parent, list[Statement] c, CloneMap[list[node]] m ) {
	for( i <- [0..size(c)], j <- [MIN_SEQUENCE_LENGTH..MAX_SEQUENCE_LENGTH] ) {
		if( i + j <= size(c) && (i+j) - i >= MIN_SEQUENCE_LENGTH ) {
			s = c[i..(i+j)];
			m[s] = s in m ? m[s] + sequenceLocation(mapper(s,getLoc)) : {sequenceLocation(mapper(s,getLoc))};
		} 
	}
	
	return m;
}

@doc {
	Generalize the names in the AST to detect type2 clones
}
public Declaration generalizeNames( Declaration ast ) {
	return visit( ast ) {
		case str _ => "string"
		case int _ => 0 
		case n:\int() => setAnnotations(string(), getAnnotations( n ) )
    	case n:short() => setAnnotations(string(), getAnnotations( n ) )
    	case n:long() => setAnnotations(string(), getAnnotations( n ) )
    	case n:float() => setAnnotations(string(), getAnnotations( n ) )
    	case n:double() => setAnnotations(string(), getAnnotations( n ) )
    	case n:char() => setAnnotations(string(), getAnnotations( n ) )
    	case n:string() => setAnnotations(string(), getAnnotations( n ) )
    	case n:byte() => setAnnotations(string(), getAnnotations( n ) )
    	case n:\void() => setAnnotations(string(), getAnnotations( n ) )
    	case n:\boolean() => setAnnotations(string(), getAnnotations( n ) )
	}
}


@doc{
	If clone class c1 contains all locations of clone class c2 return true
}
public bool containsClone( Clone c1, Clone c2 ) = c2 == { l1 | l1 <- c2, any(l2 <- c1, l1 < l2) };
public CloneMap[&T] filterTreshold( CloneMap[&T] m ) = ( k:m[k] | k <- m, smallestLoc( m[k] )  >= LINES_TRESHOLD );
public CloneMap[&T] filterClones( CloneMap[&T] m ) = ( k:m[k] | k <- m, size(m[k]) > 1 );

public list[CloneClass] createClones( CloneMap[&T] m ) = [ <smallestLoc(m[k]),m[k]> | k <- m ];

private bool hasLoc( node d ) = "src" in getAnnotations( d );
private loc getLoc( node d ) { 
	if( Declaration n := d || Statement n := d || Expression n := d ) {
		return n@src;
	}
}