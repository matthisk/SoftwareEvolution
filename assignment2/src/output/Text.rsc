module output::Text

// LIBRARY IMPORTS
import Prelude;
import IO;

// LOCAL IMPORTS
import Config;
import Util;
import Volume;

int BLOCK_SIZE = 80;
str SEP1 = left("", BLOCK_SIZE, "=");
str SEP2 = left("", BLOCK_SIZE, "-");
str SEP3 = left("", BLOCK_SIZE, "\<\>");

@doc{
	Outputs information about detected clones either to the console or to a file
}
public void outputText( list[CloneClass] clones, map[str,value] meta, bool console = true ) {
	clones = sort( clones, less );
	
	biggestCloneClass = ( <0,{}> | size(c) > size(snd(it)) ? <s,c> : it | <s,c> <- clones );
	
	projectName = "project";
	if( "project_name" in meta ) {
		projectName = meta["project_name"];
	}
	
	result ="<SEP3>
			'<wrapBlock("Generated by Rascal Clone Detector",sep="\<\>")>
			'<SEP3>
			'<wrapBlock("Software Evolution 2014",sep="\<\>")>
			'<wrapBlock("all rights reserved Matthisk Heimensen",sep="\<\>")>
			'<wrapBlock("created at: <if( "created_at" in meta && datetime d := meta["created_at"] ) {><printDate( d )><} else {><printDate(now())><}>",sep="\<\>")>
			'<if( "elapsed_time" in meta ){><wrapBlock( outputDuration( meta["elapsed_time"] ), sep="\<\>")><}>
			'<SEP3>
			'
			'<SEP1>
			'<wrapBlock("CLONE META DATA (<projectName>):",sep="+")>
			'<SEP1>
			'<wrapBlock("Detected <size(clones)> clones")>
			'<if( "lines_of_code" in meta ){><wrapBlock("Lines of code: <meta["lines_of_code"]>")><}>
			'<if( "lines_of_clones" in meta ){><wrapBlock("Lines of code clones: <meta["lines_of_clones"]>")><}>
			'<if( "percentage_of_clones" in meta ){><wrapBlock("<meta["percentage_of_clones"]>% of the code is duplicated")><}>
			'<SEP2>
			'
			'The biggest clone class has <size(snd(biggestCloneClass))> clones across <uniqueLocations(snd(biggestCloneClass))> files:<outputClones( [biggestCloneClass] )>
			'
			'The biggest clone has a size of <getLOCFile( getOneFrom(snd(head(clones))) )> lines:<outputClones( [head(clones)] )>
			'
			'<if( OUTPUT_ALL_CLONES ) {>Other Clones (sorted by #lines)
			'<SEP1>
			'<outputClones( tail(clones) )><}>";
			
	if( console ) {
		println( result );
	} else {
		if( loc project := projectName ) {
			mkDirectory(|home:///Repositories/SoftwareEvolution/reports/| + project.authority);
			location = |home:///Repositories/SoftwareEvolution/reports/| + project.authority + "report-<printDate(now(),"dd-MM-YYYY(hh:mm:ss)")>.txt";
			writeFile( location, result );
		} else {
			location = |home:///Repositories/SoftwareEvolution/reports/report-<printDate(now(),"dd-MM-YYYY(hh:mm:ss)")>.txt|;
			writeFile( location, result );
		} 
		
	}		
}

public str outputDuration( value v ) { if( Duration d := v ) { return outputDuration( d ); } else { return ""; } }
public str outputDuration( duration(years, months, days, hours, minutes, seconds, _) ) {
	return "in <if(years != 0){><years>years, <}><if(months != 0){><months>months, <}><if(hours != 0){><hours>hours, <}><if(minutes != 0){><minutes>minutes <}><if(years != 0 || months != 0 || days != 0 || hours != 0 || minutes != 0){>and <}><if(seconds != 0){><seconds>seconds<}>";
}

private str outputClones( list[CloneClass] clones ) {
	return  "<for( <s, c> <- clones ){>
			'<SEP1>
			'<wrapBlock("== CLONE CLASS ==", sep = "+")>
			'<SEP1>
			'<wrapBlock("META:",sep="+")>
			'<SEP2>
			'<wrapBlock("# Clones:      <size(c)>")>
			'<wrapBlock("Lines of code: <getLOCFile( getOneFrom(c) )>")>
			'<wrapBlock("Across files:  <uniqueLocations( c )>")>
			'<SEP2>
			'<wrapBlock("LOCATIONS:", sep="+")>
			'<SEP2>
			'<wrapBlock(outputSet( c ))>
			'<SEP2>
			'<if( OUTPUT_CLONE_CODE ) {><wrapBlock("SOURCE:", sep="+")>
			'<SEP2>
			'<for( l <- c ) {><wrapBlock( replaceAll(readFile( l ), "\t", "") )>
			'<SEP2>\n<}>
			'<}><}>";
}

public str wrapBlock( str s, str sep = "|" ) {
	result = 
	for( line <- split( "\n", s ) ) {
		append "<sep> " + left(line, BLOCK_SIZE - 1 - (2*size(sep)), " ") + "<sep>"; 
	}
	return substring(( "" | it + "\n" + l | l <- result ), 1);
}

private str outputSet( set[&T] s ) {
	result = "";
	l = toList(s);
	for( x <- l ) {
		if( x == last(l) ) result += toString(x);
		else               result += toString(x) + "\n";
	}
	return result;
}